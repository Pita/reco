// {{{regexStr}}}
function generatedRegexMatcher(str: string) {
  const strLength = str.length;
  const groupMarkers:[
    {{#each groups}}
      number, number,
    {{/each}}
  ] = [
    {{#each groups}}
      -1, -1,
    {{/each}}
  ];
  const tempGroupStartMarkers: [
    {{#each groups}}
      number, 
    {{/each}}
  ] = [
    {{#each groups}}
      -1,
    {{/each}}
  ];

  {{#each fiberHandlers}}
    const {{{functionName}}} = (
      start: number,
      {{#if hasCallback}} callback: (start: number) => number {{/if}}
    ): number => {
      let i = start;
      {{#each atoms}}
        /*
         * {{{type}}}
         * {{escapeComment posLine1}}
         * {{{posLine2}}}
         */
        {{#switchCase 'charOrSet'}}
          {{#if backwards}}
            i--;
            if (i < 0) {
              return -1;
            }
          {{/if}}
          {{#unless backwards}}
            if (i >= strLength) {
              return -1;
            }
          {{/unless}}
          const charCode{{{@index}}} = str.charCodeAt(i);
          let result{{{@index}}} = false;
          {{> leaf tree atomIndex=@index}}
          if({{#unless negate}}!{{/unless}}result{{{@index}}}) {
            return -1;
          };
          {{#unless backwards}}
            i++;
          {{/unless}}
        {{/switchCase}}
        {{#switchCase 'disjunction'}}
          {{#each groupsToRestore}}
            const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
            const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
          {{/each}}
          {{#each alternatives}}            
            const length{{{@index}}} = {{{functionName}}}(
              i, 
              {{#if hasCallback}} callback, {{/if}}
            );
            if (length{{{@index}}} !== -1) {
              return length{{{@index}}};
            }
            {{#each meta.groups}}
              groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
              groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
            {{/each}}
          {{/each}}
          return -1;
        {{/switchCase}}
        {{#switchCase 'startAnchor'}}
          if (i !== 0) {
            return -1;
          }
        {{/switchCase}}
        {{#switchCase 'endAnchor'}}
          if (i !== strLength) {
            return -1;
          }
        {{/switchCase}}
        {{#switchCase 'groupStartMarker'}}
          tempGroupStartMarkers[{{{groupReference.idx}}}] = i;
        {{/switchCase}}
        {{#switchCase 'groupEndMarker'}}
          groupMarkers[{{groupStartArrayIndex groupReference}}] = tempGroupStartMarkers[{{{groupReference.idx}}}];
          groupMarkers[{{groupEndArrayIndex groupReference}}] = i;
        {{/switchCase}}
        {{#switchCase 'lookaround'}}
          const lookaroundResult{{{@index}}} = {{{lookaroundFiber.functionName}}}(i);
          {{#if negate}}
            if (lookaroundResult{{{@index}}} !== -1) { 
          {{/if}}
          {{#unless negate}}
            if (lookaroundResult{{{@index}}} === -1) { 
          {{/unless}}
            return -1;
          }
        {{/switchCase}}
        {{#switchCase 'wordBoundary'}}
          if (i !== 0 && (i + 1) !== strLength) {
            // TODO: find way to generate these trees
            const charCodeBefore{{{@index}}} = str.charCodeAt(i-1);
            let isBeforeWord{{{@index}}} = false;
            if (charCodeBefore{{{@index}}} <= 90) {
              if (charCodeBefore{{{@index}}} <= 57) {
                isBeforeWord{{{@index}}} = charCodeBefore{{{@index}}} >= 48;
              } else {
                isBeforeWord{{{@index}}} = charCodeBefore{{{@index}}} >= 65;
              }
            } else {
              if (charCodeBefore{{{@index}}} === 95) {
                isBeforeWord{{{@index}}} = true;
              } else {
                if (charCodeBefore{{{@index}}} <= 122) {
                  isBeforeWord{{{@index}}} = charCodeBefore{{{@index}}} >= 97;
                }
              }
            }

            const charCodeAfter{{{@index}}} = str.charCodeAt(i+1);
            let isAfterWord{{{@index}}} = false;
            if (charCodeAfter{{{@index}}} <= 90) {
              if (charCodeAfter{{{@index}}} <= 57) {
                isAfterWord{{{@index}}} = charCodeAfter{{{@index}}} >= 48;
              } else {
                isAfterWord{{{@index}}} = charCodeAfter{{{@index}}} >= 65;
              }
            } else {
              if (charCodeAfter{{{@index}}} === 95) {
                isAfterWord{{{@index}}} = true;
              } else {
                if (charCodeAfter{{{@index}}} <= 122) {
                  isAfterWord{{{@index}}} = charCodeAfter{{{@index}}} >= 97;
                }
              }
            }

            {{#if negate}}
              if (isBeforeWord{{{@index}}} !== isAfterWord{{{@index}}}) {
                return -1;
              }
            {{/if}}
            {{#unless negate}}
              if (isBeforeWord{{{@index}}} === isAfterWord{{{@index}}}) {
                return -1;
              }
            {{/unless}}
          }
          {{#if negate}}
          else {
            return -1;
          }
          {{/if}}
        {{/switchCase}}
        {{#switchCase 'greedyQuantifier'}}
          {{#if maxOrMinCount}}
            let matchCount = -1;
          {{/if}}
          const followUpCallback = (start: number) => {
            {{#if followUp}}
              return {{{followUp.functionName}}}(
                start, 
                {{#if followUp.hasCallback}} callback, {{/if}}
              );
            {{/if}}
            {{#unless followUp}}
              return start;
            {{/unless}}
          }

          const recursiveCallback = (start: number): number => {
            {{#if maxOrMinCount}}
              matchCount++;
            {{/if}}

            {{#if maxCount}}
              if (matchCount === {{{maxCount}}}) {
                return followUpCallback(start);
              }
            {{/if}}

            {{#each wrappedHandler.meta.groups}}
              const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
              const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
            {{/each}}
            const tryDeeperResult = {{{wrappedHandler.functionName}}}(start, recursiveCallback);
            if (tryDeeperResult !== -1) {
              // we actually were able to go deeper, nice!
              return tryDeeperResult;
            } 

            // recursion failed, reset groups
            {{#each wrappedHandler.meta.groups}}
              groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
              groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
            {{/each}}

            {{#if minCount}}
              if (matchCount < {{{minCount}}}) {
                matchCount--;
                return -1;
              }
            {{/if}}

            {{#each followUp.meta.groups}}
              const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
              const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
            {{/each}}
            const followUpResult = followUpCallback(start);
            if (followUpResult === -1) {
              {{#each followUp.meta.groups}}
                groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
                groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
              {{/each}}
              {{#if maxOrMinCount}}
                matchCount--;
              {{/if}}
            }
            return followUpResult;
          };

          return recursiveCallback(i);
        {{/switchCase}}
        {{#switchCase 'lazyQuantifier'}}
          {{#unless followUp}}
            return i;
          {{/unless}}
          {{#if followUp}}
            {{#if maxOrMinCount}}
              let matchCount = -1;
            {{/if}}
            const followUpCallback = (start: number) => {
              return {{{followUp.functionName}}}(
                start, 
                {{#if followUp.hasCallback}} callback, {{/if}}
              );
            }

            const recursiveCallback = (start: number): number => {
              {{#if maxOrMinCount}}
                matchCount++;
              {{/if}}

              {{#if minCount}}
                if (matchCount >= {{{minCount}}}) {
              {{/if}}
                {{#each followUp.meta.groups}}
                  const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
                  const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
                {{/each}}
                const followUpResult = followUpCallback(start);
                if (followUpResult === -1) {
                  {{#each followUp.meta.groups}}
                    groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
                    groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
                  {{/each}}
                } else {
                  return followUpResult;
                }

              {{#if minCount}}
                }
              {{/if}}
              
              {{#if maxCount}}
                if (matchCount < {{{maxCount}}}) {
              {{/if}}
                {{#each wrappedHandler.meta.groups}}
                  const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
                  const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
                {{/each}}
                const tryDeeperResult = {{{wrappedHandler.functionName}}}(start, recursiveCallback);
                if (tryDeeperResult !== -1) {
                  // we actually were able to go deeper, nice!
                  return tryDeeperResult;
                }
                {{#each wrappedHandler.meta.groups}}
                  groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
                  groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
                {{/each}}
              {{#if maxCount}}
                }
              {{/if}}

              {{#if maxOrMinCount}}
                matchCount--;
              {{/if}}
              return -1;
            };

            return recursiveCallback(i);
          {{/if}}
        {{/switchCase}}
      {{/each}}
      {{#unless lastAtomReturns}}
        {{#if followUp}}
          return {{{followUp.functionName}}}(i, {{#if followUp.hasCallback}} callback {{/if}});
        {{/if}}
        {{#unless followUp}}
          return i;
        {{/unless}}
      {{/unless}}
    }
  {{/each}}

  for (let i = 0; i < strLength; i++) {
    const posAfterMatch = {{{mainHandler.functionName}}}(i);
    if (posAfterMatch !== -1) {
      return {
        index: i,
        matches: [
          str.substring(i, posAfterMatch),
          {{#each groups}}
            groupMarkers[{{groupEndArrayIndex @this}}] !== -1 // TODO: is this check still necassary?
              ? str.substring(groupMarkers[{{groupStartArrayIndex @this}}], groupMarkers[{{groupEndArrayIndex @this}}])
              : undefined,
          {{/each}}
        ]
      }
    }
  }

  return null;
};

module.exports = {generatedRegexMatcher};