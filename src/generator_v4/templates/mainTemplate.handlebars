// {{{regexStr}}}
function generatedRegexMatcher(str: string) {
  const strLength = str.length;
  let groupMarkers:[
    {{#times groupsCount}}
      number, number,
    {{/times}}
  ] = [
    {{#times groupsCount}}
      -1, -1,
    {{/times}}
  ];
  const tempGroupStartMarkers: [
    {{#times groupsCount}}
      number, 
    {{/times}}
  ] = [
    {{#times groupsCount}}
      -1,
    {{/times}}
  ];

  {{#each fiberHandlers}}
    const {{{functionName}}} = (
      start: number,
      {{#if hasCallback}} callback: (start: number) => number {{/if}}
    ): number => {
      let i = start;
      {{#each atoms}}
        /*
         * {{{type}}}
         * {{#escapeComment posLine1}}{{/escapeComment}}
         * {{{posLine2}}}
         */
        {{#atomCase 'charOrSet'}}
          {{#if backwards}}
            i--;
            if (i < 0) {
              return -1;
            }
          {{/if}}
          {{#unless backwards}}
            if (i >= strLength) {
              return -1;
            }
          {{/unless}}
          const charCode{{{@index}}} = str.charCodeAt(i);
          let result{{{@index}}} = false;
          {{> leaf tree atomIndex=@index}}
          if({{#unless negate}}!{{/unless}}result{{{@index}}}) {
            return -1;
          };
          {{#unless backwards}}
            i++;
          {{/unless}}
        {{/atomCase}}
        {{#atomCase 'disjunction'}}
          // TODO: Make that this does not require garbage collection
          // typed array or for loop
          // there might also be a possiblity to not copy all groups
          const groupMarkersCopy = groupMarkers.slice() as any;

          {{#each alternatives}}
            const length{{{@index}}} = {{{functionName}}}(
              i, 
              {{#if hasCallback}} callback, {{/if}}
            );
            if (length{{{@index}}} !== -1) {
              return length{{{@index}}};
            }
            groupMarkers = groupMarkersCopy;
          {{/each}}
          return -1;
        {{/atomCase}}
        {{#atomCase 'startAnchor'}}
          if (i !== 0) {
            return -1;
          }
        {{/atomCase}}
        {{#atomCase 'endAnchor'}}
          if (i !== strLength) {
            return -1;
          }
        {{/atomCase}}
        {{#atomCase 'groupStartMarker'}}
          tempGroupStartMarkers[{{{groupIndex}}}] = i;
        {{/atomCase}}
        {{#atomCase 'groupEndMarker'}}
          groupMarkers[{{{groupStartMarkerIndex}}}] = tempGroupStartMarkers[{{{groupIndex}}}];
          groupMarkers[{{{groupEndMarkerIndex}}}] = i;
        {{/atomCase}}
        {{#atomCase 'lookAhead'}}
          const lookAheadResult{{{@index}}} = {{{lookAheadFiber.functionName}}}(i);
          {{#if negative}}
            if (lookAheadResult{{{@index}}} !== -1) { 
          {{/if}}
          {{#unless negative}}
            if (lookAheadResult{{{@index}}} === -1) { 
          {{/unless}}
            return -1;
          }
        {{/atomCase}}
        {{#atomCase 'greedyQuantifier'}}
          {{#if maxOrMinCount}}
            let matchCount = -1;
          {{/if}}
          const followUpCallback = (start: number) => {
            {{#if followUp}}
              return {{{followUp.functionName}}}(
                start, 
                {{#if followUp.hasCallback}} callback, {{/if}}
              );
            {{/if}}
            {{#unless followUp}}
              return start;
            {{/unless}}
          }

          const recursiveCallback = (start: number): number => {
            {{#if maxOrMinCount}}
              matchCount++;
            {{/if}}

            {{#if maxCount}}
              if (matchCount === {{{maxCount}}}) {
                return followUpCallback(start);
              }
            {{/if}}

            const groupMarkersCopy = groupMarkers.slice() as any;
            const tryDeeperResult = {{{wrappedHandler.functionName}}}(start, recursiveCallback);
            if (tryDeeperResult !== -1) {
              // we actually were able to go deeper, nice!
              return tryDeeperResult;
            } 

            // recursion failed, reset groups
            groupMarkers = groupMarkersCopy;

            {{#if minCount}}
              if (matchCount < {{{minCount}}}) {
                matchCount--;
                return -1;
              }
            {{/if}}

            const followUpResult = followUpCallback(start);
            if (followUpResult === -1) {
              groupMarkers = groupMarkersCopy;
              {{#if maxOrMinCount}}
                matchCount--;
              {{/if}}
            }
            return followUpResult;
          };

          return recursiveCallback(i);
        {{/atomCase}}
        {{#atomCase 'lazyQuantifier'}}
          {{#unless followUp}}
            return i;
          {{/unless}}
          {{#if followUp}}
            {{#if maxOrMinCount}}
              let matchCount = -1;
            {{/if}}
            const groupMarkersCopy = groupMarkers.slice() as any;

            const followUpCallback = (start: number) => {
              return {{{followUp.functionName}}}(
                start, 
                {{#if followUp.hasCallback}} callback, {{/if}}
              );
            }

            const recursiveCallback = (start: number): number => {
              {{#if maxOrMinCount}}
                matchCount++;
              {{/if}}

              {{#if minCount}}
                if (matchCount >= {{{minCount}}}) {
              {{/if}}
                const followUpResult = followUpCallback(start);
                if (followUpResult === -1) {
                  groupMarkers = groupMarkersCopy;
                } else {
                  return followUpResult;
                }

              {{#if minCount}}
                }
              {{/if}}
              
              {{#if maxCount}}
                if (matchCount < {{{maxCount}}}) {
              {{/if}}
                const tryDeeperResult = {{{wrappedHandler.functionName}}}(start, recursiveCallback);
                if (tryDeeperResult !== -1) {
                  // we actually were able to go deeper, nice!
                  return tryDeeperResult;
                }
                groupMarkers = groupMarkersCopy;
              {{#if maxCount}}
                }
              {{/if}}

              {{#if maxOrMinCount}}
                matchCount--;
              {{/if}}
              return -1;
            };

            return recursiveCallback(i);
          {{/if}}
        {{/atomCase}}
      {{/each}}
      {{#unless lastAtomReturns}}
        {{#if followUp}}
          return {{{followUp.functionName}}}(i, {{#if followUp.hasCallback}} callback {{/if}});
        {{/if}}
        {{#unless followUp}}
          return i;
        {{/unless}}
      {{/unless}}
    }
  {{/each}}

  for (let i = 0; i < strLength; i++) {
    const length = {{{mainHandler.functionName}}}(i);
    if (length !== -1) {
      // TODO: why do we do this?!
      groupMarkers[0] = i;
      groupMarkers[1] = length;
      return {
        index: i,
        matches: [
          {{#times groupsCount}}
            groupMarkers[{{@index}} * 2 + 1] !== -1 
              ? str.substring(groupMarkers[{{@index}} * 2], groupMarkers[{{@index}} * 2 + 1])
              : undefined,
          {{/times}}
        ]
      }
    }
  }

  return null;
};

module.exports = {generatedRegexMatcher};