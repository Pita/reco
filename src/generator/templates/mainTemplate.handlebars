// {{{regexStr}}}
export function generatedRegexMatcher(str: string) {
  const strLength = str.length;
  const groupMarkers:[
    {{#each groups}}
      number, number,
    {{/each}}
  ] = [
    {{#each groups}}
      -1, -1,
    {{/each}}
  ];
  const tempGroupStartMarkers: [
    {{#each groups}}
      number, 
    {{/each}}
  ] = [
    {{#each groups}}
      -1,
    {{/each}}
  ];

  {{#each fiberHandlers}}
    const {{{functionName}}} = (
      start: number,
      {{#if hasCallback}} callback: (start: number) => number {{/if}}
    ): number => {
      let i = start;
      {{#each atoms}}
        /*
         * {{{type}}}
         * {{escapeComment posLine1}}
         * {{{posLine2}}}
         */
        {{#switchCase 'charOrSet'}}
          if (i >= strLength) {
            return -1;
          }
          const charCode{{{@index}}} =
          {{#if unicode}}
            str.codePointAt(i)!;
          {{/if}}
          {{#unless unicode}}
            str.charCodeAt(i);
          {{/unless}}
          let result{{{@index}}} = false;
          {{> leaf tree atomIndex=@index}}
          if({{#unless negate}}!{{/unless}}result{{{@index}}}) {
            return -1;
          };
          {{#if unicode}}
            // surrogate pair might require moving 2 chars ahead
            i += charCode{{{@index}}} >= 0x10000 ? 2 : 1
          {{/if}}
          {{#unless unicode}}
            i++;
          {{/unless}}
        {{/switchCase}}
        {{#switchCase 'charOrSetBackward'}}
          {{#if unicode}}
            let isSurrogatePair{{{@index}}} = false;
            if (i >= 2) {
              const charCodeBefore{{{@index}}} = str.charCodeAt(i - 2);
              if (charCodeBefore{{{@index}}} >= 0xD800 && charCodeBefore{{{@index}}} <= 0xDBFF) {
                isSurrogatePair{{{@index}}} = true;
              }
            } 
            i -= isSurrogatePair{{{@index}}} ? 2 : 1;
          {{/if}}
          {{#unless unicode}}
            i--;
          {{/unless}}
          if (i < 0) {
            return -1;
          }
          const charCode{{{@index}}} =
            {{#if unicode}}
              str.codePointAt(i);
            {{/if}}
            {{#unless unicode}}
              str.charCodeAt(i);
            {{/unless}}
          let result{{{@index}}} = false;
          {{> leaf tree atomIndex=@index}}
          if({{#unless negate}}!{{/unless}}result{{{@index}}}) {
            return -1;
          };
        {{/switchCase}}
        {{#switchCase 'disjunction'}}
          {{#each groupsToRestore}}
            const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
            const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
          {{/each}}
          {{#each alternatives}}            
            const length{{{@index}}} = {{{functionName}}}(
              i, 
              {{#if hasCallback}} callback, {{/if}}
            );
            if (length{{{@index}}} !== -1) {
              return length{{{@index}}};
            }
            {{#each meta.groups}}
              groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
              groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
            {{/each}}
          {{/each}}
          return -1;
        {{/switchCase}}
        {{#switchCase 'startAnchor'}}
          if (i !== 0) {
            return -1;
          }
        {{/switchCase}}
        {{#switchCase 'endAnchor'}}
          if (i !== strLength) {
            return -1;
          }
        {{/switchCase}}
        {{#switchCase 'multiLineStartAnchor'}}
          if (i !== 0) {
            const charCodeMultiLineStartAnchor{{{index}}} = str.charCodeAt(i - 1);
            let isNewLineChar{{{index}}} = false;
            // TODO: find way to generate these trees
            if (charCodeMultiLineStartAnchor{{{index}}} <= 13) {
              isNewLineChar{{{index}}} = charCodeMultiLineStartAnchor{{{index}}} === 10 || charCodeMultiLineStartAnchor{{{index}}} === 13;
            } else {
              if (charCodeMultiLineStartAnchor{{{index}}} <= 8233) {
                isNewLineChar{{{index}}} = charCodeMultiLineStartAnchor{{{index}}} >= 8232;
              }
            }
            if (!isNewLineChar{{{index}}}) {
              return -1;
            }
          }

        {{/switchCase}}
        {{#switchCase 'multiLineEndAnchor'}}
          if (i !== strLength) {
            const charCodeMultiLineEndAnchor{{{index}}} = str.charCodeAt(i);
            let isNewLineChar{{{index}}} = false;
            // TODO: find way to generate these trees
            if (charCodeMultiLineEndAnchor{{{index}}} <= 13) {
              isNewLineChar{{{index}}} = charCodeMultiLineEndAnchor{{{index}}} === 10 || charCodeMultiLineEndAnchor{{{index}}} === 13;
            } else {
              if (charCodeMultiLineEndAnchor{{{index}}} <= 8233) {
                isNewLineChar{{{index}}} = charCodeMultiLineEndAnchor{{{index}}} >= 8232;
              }
            }
            if (!isNewLineChar{{{index}}}) {
              return -1;
            }
          }
        {{/switchCase}}
        {{#switchCase 'groupStartMarker'}}
          tempGroupStartMarkers[{{{groupReference.idx}}}] = i;
        {{/switchCase}}
        {{#switchCase 'groupEndMarker'}}
          groupMarkers[{{groupStartArrayIndex groupReference}}] = tempGroupStartMarkers[{{{groupReference.idx}}}];
          groupMarkers[{{groupEndArrayIndex groupReference}}] = i;
        {{/switchCase}}
        {{#switchCase 'lookaround'}}
          const lookaroundResult{{{@index}}} = {{{lookaroundFiber.functionName}}}(i);
          {{#if negate}}
            if (lookaroundResult{{{@index}}} !== -1) { 
          {{/if}}
          {{#unless negate}}
            if (lookaroundResult{{{@index}}} === -1) { 
          {{/unless}}
            return -1;
          }
        {{/switchCase}}
        {{#switchCase 'wordBoundary'}}
          if (i !== 0 && (i + 1) !== strLength) {
            // TODO: find way to generate these trees
            const charCodeBefore{{{@index}}} = str.charCodeAt(i-1);
            let isBeforeWord{{{@index}}} = false;
            if (charCodeBefore{{{@index}}} <= 90) {
              if (charCodeBefore{{{@index}}} <= 57) {
                isBeforeWord{{{@index}}} = charCodeBefore{{{@index}}} >= 48;
              } else {
                isBeforeWord{{{@index}}} = charCodeBefore{{{@index}}} >= 65;
              }
            } else {
              if (charCodeBefore{{{@index}}} === 95) {
                isBeforeWord{{{@index}}} = true;
              } else {
                if (charCodeBefore{{{@index}}} <= 122) {
                  isBeforeWord{{{@index}}} = charCodeBefore{{{@index}}} >= 97;
                }
              }
            }

            const charCodeAfter{{{@index}}} = str.charCodeAt(i+1);
            let isAfterWord{{{@index}}} = false;
            if (charCodeAfter{{{@index}}} <= 90) {
              if (charCodeAfter{{{@index}}} <= 57) {
                isAfterWord{{{@index}}} = charCodeAfter{{{@index}}} >= 48;
              } else {
                isAfterWord{{{@index}}} = charCodeAfter{{{@index}}} >= 65;
              }
            } else {
              if (charCodeAfter{{{@index}}} === 95) {
                isAfterWord{{{@index}}} = true;
              } else {
                if (charCodeAfter{{{@index}}} <= 122) {
                  isAfterWord{{{@index}}} = charCodeAfter{{{@index}}} >= 97;
                }
              }
            }

            {{#if negate}}
              if (isBeforeWord{{{@index}}} !== isAfterWord{{{@index}}}) {
                return -1;
              }
            {{/if}}
            {{#unless negate}}
              if (isBeforeWord{{{@index}}} === isAfterWord{{{@index}}}) {
                return -1;
              }
            {{/unless}}
          }
          {{#if negate}}
          else {
            return -1;
          }
          {{/if}}
        {{/switchCase}}
        {{#switchCase 'groupBackReference'}}
        if ({{{endGroupMarkerIndex}}} < groupMarkers.length) {
          let backReferenceI{{{index}}} = groupMarkers[{{{startGroupMarkerIndex}}}];
          const backReferenceEnd{{{index}}} = groupMarkers[{{{endGroupMarkerIndex}}}];
          while(backReferenceI{{{index}}} < backReferenceEnd{{{index}}}) {
            if (i >= strLength) {
              return -1;
            }

            const backReferenceCharCode = str.charCodeAt(backReferenceI{{{index}}});
            const currentCharCode = str.charCodeAt(i);

            if (backReferenceCharCode !== currentCharCode) {
              return -1;
            }

            backReferenceI{{{index}}}++;
            i++;
          }
        }
        {{/switchCase}}
        {{#switchCase 'greedyQuantifierStarter'}}
          {{#if maxOrMinCount}}
            let matchCountCopy{{{functionName}}} = {{{functionName}}}matchCount;
            {{{functionName}}}matchCount = -1;
          {{/if}}
          const cursorAfterGreedyQuantifier = {{{functionName}}}(i);
          {{#if maxOrMinCount}}
            {{{functionName}}}matchCount = matchCountCopy{{{functionName}}};
          {{/if}}

          return cursorAfterGreedyQuantifier;
        {{/switchCase}}
        {{#switchCase 'lazyQuantifier'}}
          {{#unless followUp}}
            return i;
          {{/unless}}
          {{#if followUp}}
            {{#if maxOrMinCount}}
              let matchCount = -1;
            {{/if}}
            const followUpCallback = (start: number) => {
              return {{{followUp.functionName}}}(
                start, 
                {{#if followUp.hasCallback}} callback, {{/if}}
              );
            }

            const recursiveCallback = (start: number): number => {
              {{#if maxOrMinCount}}
                matchCount++;
              {{/if}}

              {{#if minCount}}
                if (matchCount >= {{{minCount}}}) {
              {{/if}}
                {{#each followUp.meta.groups}}
                  const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
                  const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
                {{/each}}
                const followUpResult = followUpCallback(start);
                if (followUpResult === -1) {
                  {{#each followUp.meta.groups}}
                    groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
                    groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
                  {{/each}}
                } else {
                  return followUpResult;
                }

              {{#if minCount}}
                }
              {{/if}}
              
              {{#if maxCount}}
                if (matchCount < {{{maxCount}}}) {
              {{/if}}
                {{#each wrappedHandler.meta.groups}}
                  const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
                  const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
                {{/each}}
                const tryDeeperResult = {{{wrappedHandler.functionName}}}(start, recursiveCallback);
                if (tryDeeperResult !== -1) {
                  // we actually were able to go deeper, nice!
                  return tryDeeperResult;
                }
                {{#each wrappedHandler.meta.groups}}
                  groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
                  groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
                {{/each}}
              {{#if maxCount}}
                }
              {{/if}}

              {{#if maxOrMinCount}}
                matchCount--;
              {{/if}}
              return -1;
            };

            return recursiveCallback(i);
          {{/if}}
        {{/switchCase}}
      {{/each}}
      {{#unless lastAtomReturns}}
        {{#if followUp}}
          return {{{followUp.functionName}}}(i, {{#if followUp.hasCallback}} callback {{/if}});
        {{/if}}
        {{#unless followUp}}
          return i;
        {{/unless}}
      {{/unless}}
    }
  {{/each}}

  {{#each greedyQuantifierHandlers}}
     /*
      * {{escapeComment posLine1}}
      * {{{posLine2}}}
      */
    {{#if maxOrMinCount}}
      let {{{functionName}}}matchCount = -1;
    {{/if}}

    const {{{functionName}}} = (
      start: number,
    ): number => {
      {{#if maxOrMinCount}}
        {{{functionName}}}matchCount++;
      {{/if}}

      {{#if maxCount}}
        if ({{{functionName}}}matchCount === {{{maxCount}}}) {
          {{#if followUp}}
            return {{{followUp.functionName}}}(
              start, 
              {{#if followUp.hasCallback}} callback, {{/if}}
            );
          {{/if}}
          {{#unless followUp}}
            return start;
          {{/unless}}
        }
      {{/if}}

      {{#each wrappedHandler.meta.groups}}
        const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
        const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
      {{/each}}
      const tryDeeperResult = {{{wrappedHandler.functionName}}}(start);
      if (tryDeeperResult !== -1) {
        // we actually were able to go deeper, nice!
        return tryDeeperResult;
      } 

      // recursion failed, reset groups
      {{#each wrappedHandler.meta.groups}}
        groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
        groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
      {{/each}}

      {{#if minCount}}
        if ({{{functionName}}}matchCount < {{{minCount}}}) {
          {{{functionName}}}matchCount--;
          return -1;
        }
      {{/if}}

      {{#if followUp}}
        {{#each followUp.meta.groups}}
          const groupMarkerCopy{{{groupStartArrayIndex @this}}} = groupMarkers[{{groupStartArrayIndex @this}}];
          const groupMarkerCopy{{{groupEndArrayIndex @this}}} = groupMarkers[{{groupEndArrayIndex @this}}];
        {{/each}}

        const followUpResult = {{{followUp.functionName}}}(
          start, 
        );

        if (followUpResult === -1) {
          {{#each followUp.meta.groups}}
            groupMarkers[{{groupStartArrayIndex @this}}] = groupMarkerCopy{{{groupStartArrayIndex @this}}};
            groupMarkers[{{groupEndArrayIndex @this}}] = groupMarkerCopy{{{groupEndArrayIndex @this}}};
          {{/each}}
          {{#if maxOrMinCount}}
            {{{functionName}}}matchCount--;
          {{/if}}
        }
        return followUpResult;
      {{/if}}
      {{#unless followUp}}
        return start;
      {{/unless}}
    }
  {{/each}}

  for (let i = 0; i < strLength; i++) {
    const posAfterMatch = {{{mainHandler.functionName}}}(i);
    if (posAfterMatch !== -1) {
      return {
        index: i,
        matches: [
          str.substring(i, posAfterMatch),
          {{#each groups}}
            groupMarkers[{{groupEndArrayIndex @this}}] !== -1 // TODO: is this check still necassary?
              ? str.substring(groupMarkers[{{groupStartArrayIndex @this}}], groupMarkers[{{groupEndArrayIndex @this}}])
              : undefined,
          {{/each}}
        ]
      }
    }
  }

  return null;
};